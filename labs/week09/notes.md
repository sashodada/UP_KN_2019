# Указатели

Както си говорихме на по време на упражнението, можем да считаме, че указателите са променливи, съдържащи адрес на променлива (lvalue) в паметта, като те също могат да приемат специална стойност **nullptr**, която означава, че сочат към нищо. 

### Дефиниция
Ако имаме променлива от тип `Т`, то указателят към нея е от тип `Т*`.  
Примери:  

| тип  | указател |  
| ---- | -------- |  
|int   |int*      |  
|double| double*  |  
|char  | char*    |  
|int*  | int**    |   

и така нататък...

### Операции с указатели
* рефериране -> **&**\<lvalue\>
```cpp
int a = 5;
int *ptrA = &a;
```
Тук все едно казваме *"нека `ptrA` съдържа адреса на `a` в паметта"*. Ако опитаме да изведем `ptrA`, неговата стойност ще е нещо от рода на 0x60ff18, например. Това е адрес в паметта.
**Важно** Задължително е реферираната стойност да е *lvalue*, тоест по-просто казано да не е литерал, следният израз е грешен `int* ptrA = &5`. 5 е литерал, не е заделена памет за него, респективно няма адрес.  
* дерефериране -> **\***\<указател>
```cpp
int a = 5;
int *ptrA = &a;
cout << *ptrA; \\ ще изведе 5 (стойността на а)
```
На думи тази операция би звучала така *дереферирането дава стойността, на променливата, към която `ptrA` сочи*.  
* сравнение: **==, <=, >=, <, >**
```cpp
int a = 5, b = 5;
int *ptrA = &a, *ptrA1 = &a, ptrB = &b;
cout << (ptrA == ptrA1); // 1 (true)
cout << (ptrA == ptrB);  // 0 (false)
```
Второто сравнение, връща лъжа, защото, въпреки че имат еднаква стойност, `a` и `b` се намират на различни адреси, за всяко от тях е заделена отделна клетка в паметта.

* указателна аритметика: **++, --, -=, +=**  
Извършвва се, взимайки се предвид типа на променливата, към която указателят сочи и се прибавят/изваждат съответния брой байтове към адреса.
```cpp
int a = 5;
int *ptrA = &a;
cout << ptrA << endl; // например адрес: 0x60ff00
cout << ++ptrA << endl; // тип int, тоест + 4В 0x60ff04
cout << --ptrA << endl; // тук се изваждат 4В -> 0x60ff00
ptrA += 3;  // прибавят се 3 * 4В -> ptrA = 0x60ff0c
cout << ptrA;
```


### Примерни задачи 
#### Зад. 1
Да се напише програма, която намира сумата на две числа чрез указатели.  
Решение:
```cpp
int a, b;
cin >> a;
cin >> b;
int *pA = &a, *pB = &b;
int sum = *pA + *pB;
cout << sum;
```  
#### Зад.2
Да се напише функция maxNum, която намира по-голямото от 2 числа, използвайки указатели.
```cpp
int maxNum(int *pA, int *pB) 
{
    return (*pA > *pB) ? *pA : *pB;
}

int main() 
{
    int a, b;
    cin >> a;
    cin >> b;
    cout << maxNum(&a, &b);
}
```   

#### Зад. 3  
Да се изведат елементите на масив чрез указатели.  
```cpp
int arr[] = {1, 2, 3, 4, 5, 6, 7, 8};

for(int i = 0; i < 8; i++) 
{
	cout << *(arr + i);
}
```
Tук използваме, че **името на масива е константен указател към първия му елемент** и свойствата на указателната аритметика, тоест за нулевия елемент гледаме точно началото на масива, за първия отместваме указателя с 1, тоест прибавяме 4В (размера на тип int), за втория прибавяме 2\*4В = 8В към адреса, за третия 3\*4В=12В и тн.

#### Зад. 4
Да се изведат елементите на масив в обратен ред чрез указатели.
```cpp
int arr[] = {1, 2, 3, 4, 5, 6, 7, 8};
int arrLen = 8;
int *ptr = arr + arrLen;
while(ptr != arr) 
{
	ptr--;
	cout << *ptr << " ";
}
```
Tук отново използваме свойството, че името на масива е указател към първия му елемент: прибавяйки броя на елементите, ние отместваме указателя в края на масива и го намаляваме докато не стигне началото като на всяка стъпка извеждаме елемента, към който `ptr` сочи.

#### Зад. 5
Да се напише функция, която приема 3 аргумента: указатели към числа и запазва в първия най-малкото, във втория второто по големина, в третия най-голямото от числата. 
```cpp
void orderArgs(int *a, int *b, int *c)
{
    if(*a > *c)
    {
        swap(*a, *c);
    }

    if(*a > *b)
    {
        swap(*a, *b);
    }
    // в момента най-малкият е в а
    // остава да подредим останалите 2
    if(*b > *c)
    {
        swap(*b, *c);
    }
}

int main() 
{
    int a = 5, b = 2, c = -3;
    orderArgs(&a, &b, &c);
    cout << a << " " << b << " " << c; // -3 2 5
}
```
